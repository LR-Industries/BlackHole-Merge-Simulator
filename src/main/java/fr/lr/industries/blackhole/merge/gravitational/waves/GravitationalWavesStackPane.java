package fr.lr.industries.blackhole.merge.gravitational.waves;

// Import the required classes and packages
import fr.lr.industries.blackhole.merge.utils.StackPaneMaker;
import fr.lr.industries.blackhole.merge.utils.FontUtils;
import javafx.animation.AnimationTimer;
import javafx.geometry.Pos;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Label;
import javafx.scene.layout.StackPane;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import java.util.HashMap;
import static fr.lr.industries.blackhole.merge.Simulator.*;

// The GravitationalWavesStackPane class is used to create the stack pane for the gravitational waves generated by the black holes
public class GravitationalWavesStackPane implements StackPaneMaker {
    // The WIDTH and HEIGHT variables are used to store the width and height of the screen
    private final double WIDTH;
    private final double HEIGHT;

    // The canvas variable is used to store the canvas for the simulation
    private final Canvas canvas;

    // The gc variable is used to store the graphics context of the canvas
    private final GraphicsContext gc;

    // The animationTimer variable is used to store the animation timer for the gravitational waves
    private AnimationTimer animationTimer;

    // The started variable is used to store if the animation has started or not
    private boolean started = false;

    // Set the duration of the sound to the sound duration (in milliseconds)
    private final int DURATION = 125;

    // The OLD_WAVE_FREQUENCY variable is used to store the old gravitational wave frequency
    private double OLD_WAVE_FREQUENCY = GRAVITATIONAL_WAVE_FREQUENCY;
    // The MAX_GRAVITATIONAL_WAVE_FREQUENCY variable is used to store the maximum gravitational wave frequency
    public double MAX_GRAVITATIONAL_WAVE_FREQUENCY = GRAVITATIONAL_WAVE_FREQUENCY;

    // The gravitationalWaves variable is used to store the gravitational waves as a hashmap that stores the frame number with its gravitational wave frequency
    private final HashMap<Integer, Double> gravitationalWaves = new HashMap<>();
    // The gravitationalWavesSinus variable is used to store the gravitational waves as a hashmap that stores the frame number with its gravitational wave frequency
    private final HashMap<Integer, Double> gravitationalWavesSinus = new HashMap<>();

    // The isMuted variable is used to store if the sound is muted or not
    private boolean isMuted = false;

    // The GravitationalWavesStackPane constructor is used to create a new instance of the GravitationalWavesStackPane class
    public GravitationalWavesStackPane(final double width, final double height) {
        // Set the width and height of the screen
        this.WIDTH = width;
        this.HEIGHT = height;

        // Create a canvas to the size of the screen
        this.canvas = new Canvas(this.WIDTH, this.HEIGHT);
        // Get the graphics context of the canvas
        this.gc = this.canvas.getGraphicsContext2D();
    }

    // The getStackPane method is used to get the stack pane
    @Override
    public StackPane getStackPane() {
        // Create a currentFrequencyLabel to display the gravitational wave frequency
        final Label currentFrequencyLabel = new Label(GRAVITATIONAL_WAVE_FREQUENCY + " Hz");
        // Set the text color of the currentFrequencyLabel to the label frequency color
        currentFrequencyLabel.setTextFill(LABEL_FREQUENCY_COLOR);
        // Set the font of the currentFrequencyLabel
        currentFrequencyLabel.setFont(FontUtils.getFont("Montserrat-Bold", 20));
        // Put the currentFrequencyLabel at the left high corner of the screen
        StackPane.setAlignment(currentFrequencyLabel, Pos.TOP_LEFT);
        // Create a maximumFrequencyLabel to display the maximum gravitational wave frequency
        final Label maximumFrequencyLabel = new Label(GRAVITATIONAL_WAVE_FREQUENCY + " Hz");
        // Set the text color of the maximumFrequencyLabel to the label frequency color
        maximumFrequencyLabel.setTextFill(LABEL_FREQUENCY_COLOR);
        // Set the font of the maximumFrequencyLabel
        maximumFrequencyLabel.setFont(FontUtils.getFont("Montserrat-Bold", 20));
        // Put the maximumFrequencyLabel at the left low corner of the screen
        StackPane.setAlignment(maximumFrequencyLabel, Pos.BOTTOM_LEFT);

        // Fill the canvas with the background color
        this.gc.setFill(BACKGROUND_COLOR);
        this.gc.fillRect(0, 0, WIDTH, HEIGHT);

        // Draw a border around the canvas with the border color
        this.gc.setStroke(BORDER_COLOR);
        this.gc.strokeRect(0, 0, WIDTH, HEIGHT);

        // The animationTimer variable is used to store the animation timer for the simulation
        animationTimer = new AnimationTimer() {
            // The handle method is called every frame of the simulation
            @Override
            public void handle(long now) {
                // Get the elapsed time since the last frame
                final long elapsedTime = now - LAST_FRAME_TIME_SIMULATOR;

                // If the elapsed time is greater than the frame time, update this canvas
                if (elapsedTime >= FRAME_TIME) {
                    // Fill the canvas with the background color
                    gc.setFill(BACKGROUND_COLOR);
                    gc.fillRect(0, 0, WIDTH, HEIGHT);

                    // Draw a border around the canvas with the border color
                    gc.setStroke(BORDER_COLOR);
                    gc.strokeRect(0, 0, WIDTH, HEIGHT);

                    // Check if the gravitational wave frequency is not 0 and if it is different from the old gravitational wave frequency
                    if (GRAVITATIONAL_WAVE_FREQUENCY != 0 && GRAVITATIONAL_WAVE_FREQUENCY != OLD_WAVE_FREQUENCY) {
                        // Check if both black holes are enabled
                        if (BLACK_HOLE_1.isEnabled() && BLACK_HOLE_2.isEnabled()) {
                            // Set the old gravitational wave frequency to the gravitational wave frequency
                            OLD_WAVE_FREQUENCY = GRAVITATIONAL_WAVE_FREQUENCY;

                            // Set the currentFrequencyLabel text to the gravitational wave frequency, and round it to the nearest integer
                            currentFrequencyLabel.setText(String.format("%.0f", GRAVITATIONAL_WAVE_FREQUENCY) + " Hz");

                            // Check if the gravitational wave frequency is greater than the maximum gravitational wave frequency
                            if (GRAVITATIONAL_WAVE_FREQUENCY > MAX_GRAVITATIONAL_WAVE_FREQUENCY || MAX_GRAVITATIONAL_WAVE_FREQUENCY == 0) {
                                // Set the maximum gravitational wave frequency to the gravitational wave frequency
                                MAX_GRAVITATIONAL_WAVE_FREQUENCY = GRAVITATIONAL_WAVE_FREQUENCY;
                                // Set the maximumFrequencyLabel text to the maximum gravitational wave frequency, and round it to the nearest integer
                                maximumFrequencyLabel.setText(String.format("%.0f", MAX_GRAVITATIONAL_WAVE_FREQUENCY) + " Hz");
                            }

                            // Add the gravitational wave frequency to the gravitational waves map
                            gravitationalWavesSinus.put(gravitationalWavesSinus.size() + 1, Math.sin(GRAVITATIONAL_WAVE_FREQUENCY * Math.PI * 2 / 40));
                            gravitationalWaves.put(gravitationalWaves.size() + 1, GRAVITATIONAL_WAVE_FREQUENCY);

                            // Calculate the minimum and maximum values of the gravitational waves sinus map
                            double minX = Double.MAX_VALUE, maxX = Double.MIN_VALUE;
                            double minY = Double.MAX_VALUE, maxY = Double.MIN_VALUE;
                            // Loop through the gravitational waves map
                            for (final int x : gravitationalWavesSinus.keySet()) {
                                // Get the value of the gravitational wave
                                final double y = gravitationalWavesSinus.get(x);
                                // If the value is smaller than the minimum value, set the minimum value to the value
                                if (x < minX) minX = x;
                                // If the value is greater than the maximum value, set the maximum value to the value
                                if (x > maxX) maxX = x;
                                // If the value is smaller than the minimum value, set the minimum value to the value
                                if (y < minY) minY = y;
                                // If the value is greater than the maximum value, set the maximum value to the value
                                if (y > maxY) maxY = y;
                            }

                            // Calculate the scale of the gravitational waves
                            final double scaleX = WIDTH / (maxX - minX);
                            final double scaleY = HEIGHT / (maxY - minY);

                            // Loop through the gravitational waves map
                            for (final int x : gravitationalWavesSinus.keySet()) {
                                // Get the value of the gravitational wave
                                final double y = gravitationalWavesSinus.get(x);
                                // If there is no gravitational wave at the previous x coordinate, continue
                                if (!gravitationalWavesSinus.containsKey(x - 1)) continue;
                                // Calculate the pixel coordinates using the previous calculated scale
                                final double pixelX = (x - minX) * scaleX;
                                final double pixelY = HEIGHT - (y - minY) * scaleY;
                                // Calculate the previous pixel coordinates, still using the previous calculated scale
                                final double previousPixelX = (x - 1 - minX) * scaleX;
                                final double previousPixelY = HEIGHT - (gravitationalWavesSinus.get(x - 1) - minY) * scaleY;
                                // Set the stroke color of the graphics context to the gravitational wave color
                                gc.setStroke(GRAVITATIONAL_WAVE_COLOR);
                                // Draw a line from the previous pixel coordinates to the pixel coordinates to get a smooth line graph-a-like effect
                                gc.strokeLine(previousPixelX, previousPixelY, pixelX, pixelY);
                            }

                            // If the isMuted variable is set to true, return, so the sound won't be played, and we keep the performance
                            if (isMuted) return;

                            // Create a new audio format with the specified frequency, sample size in bits, channels, signed, big endian
                            final AudioFormat format = new AudioFormat(44100, 8, 1, true, true);
                            // Create a new source data line with the specified audio format
                            SourceDataLine line;
                            // Try to open the line with the specified audio format and the specified buffer size
                            try {
                                // Open the line with the specified audio format and the specified buffer size
                                line = AudioSystem.getSourceDataLine(format);
                                // Open the line
                                line.open(format, 44100);
                            } catch (LineUnavailableException e) {
                                // If an error occurs, print the stack trace
                                throw new RuntimeException(e);
                            }
                            // Start the line
                            line.start();

                            // Create a final variable of the line
                            final SourceDataLine finalLine = line;

                            // Create a new thread to play the sound
                            new Thread(() -> {
                                // Create a new byte array with the specified size
                                final byte[] buffer = new byte[44100 * DURATION / 1000];
                                // Loop through the byte array
                                for (int i = 0; i < buffer.length; i++) {
                                    // Set the angle of the sound
                                    final double angle = 2.0 * Math.PI * i * (float) GRAVITATIONAL_WAVE_FREQUENCY / 44100;
                                    // Set the value of the byte in the byte array
                                    buffer[i] = (byte) (Math.sin(angle) * 127 * 0.05);
                                }
                                // Write the byte array to the line
                                finalLine.write(buffer, 0, buffer.length);
                                // Drain the line
                                finalLine.drain();
                                // Stop the line
                                finalLine.stop();
                                // Close the line
                                finalLine.close();
                            }).start(); // Start the thread
                        }
                    }
                }
            }

            // The start method is called when the animation timer is started
            @Override
            public void start() {
                // Set the started variable to true
                started = true;

                // Call the super method
                super.start();
            }

            // The stop method is called when the animation timer is stopped
            @Override
            public void stop() {
                // Set the started variable to false
                started = false;

                // Call the super method
                super.stop();
            }
        };

        // Create a new stack pane with the canvas and return it
        return new StackPane(canvas, currentFrequencyLabel, maximumFrequencyLabel);
    }

    // The reset method is used to reset the gravitational waves
    public void reset() {
        // Clear the gravitational waves map
        gravitationalWavesSinus.clear();
        // Clear the gravitational waves sinus map
        gravitationalWaves.clear();
        // First fill the canvas with the background color
        gc.setFill(BACKGROUND_COLOR);
        gc.fillRect(0, 0, WIDTH, HEIGHT);
        // Draw a border around the canvas with the border color
        gc.setStroke(BORDER_COLOR);
        gc.strokeRect(0, 0, WIDTH, HEIGHT);
        // Set the MAX_GRAVITATIONAL_WAVE_FREQUENCY to 0
        MAX_GRAVITATIONAL_WAVE_FREQUENCY = 0;
        // Set the GRAVITATIONAL_WAVE_FREQUENCY to 0
        GRAVITATIONAL_WAVE_FREQUENCY = 0;
    }

    // The getAnimationTimer method is used to get the animation timer
    public AnimationTimer getAnimationTimer() {
        // Return the animation timer
        return animationTimer;
    }

    // The isStarted method is used to check if the animation timer is started
    public boolean isStarted() {
        // Return the started variable
        return started;
    }

    // The isMuted method is used to check if the sound is muted
    public boolean isMuted() {
        // Return the isMuted variable
        return isMuted;
    }

    // The setMuted method is used to set the muted variable
    public void setMuted(final boolean muted) {
        // Set the isMuted variable to the specified value
        this.isMuted = muted;
    }

    // The getWidth method is used to get the width of this stack pane
    public double getWidth() {
        // Return the width of this stack pane
        return this.WIDTH;
    }

    // The getHeight method is used to get the height of this stack pane
    public double getHeight() {
        // Return the height of this stack pane
        return this.HEIGHT;
    }
}
